import SwiftUI

// MARK: - Enhanced Button Component
/// 統一ボタンコンポーネント - 最小タッチターゲット、ハプティックフィードバック対応

struct EnhancedButton<Label: View>: View {
    let action: () -> Void
    let label: Label
    let style: ButtonInteractionStyle
    let hapticFeedback: HapticFeedbackType
    let minimumTouchTarget: Bool
    
    init(
        action: @escaping () -> Void,
        style: ButtonInteractionStyle = .standard,
        hapticFeedback: HapticFeedbackType = .light,
        minimumTouchTarget: Bool = true,
        @ViewBuilder label: () -> Label
    ) {
        self.action = action
        self.style = style
        self.hapticFeedback = hapticFeedback
        self.minimumTouchTarget = minimumTouchTarget
        self.label = label()
    }
    
    var body: some View {
        Button(action: {
            HapticManager.shared.trigger(hapticFeedback)
            action()
        }) {
            label
                .frame(minWidth: minimumTouchTarget ? 44 : nil, minHeight: minimumTouchTarget ? 44 : nil)
                .contentShape(Rectangle())
        }
        .buttonStyle(style.swiftUIStyle)
        .accessibilityAddTraits(.isButton)
    }
}

// MARK: - Button Interaction Styles

enum ButtonInteractionStyle {
    case standard
    case prominent
    case subtle
    case destructive
    case floating
    
    var swiftUIStyle: some ButtonStyle {
        switch self {
        case .standard:
            return StandardButtonStyle()
        case .prominent:
            return ProminentButtonStyle()
        case .subtle:
            return SubtleButtonStyle()
        case .destructive:
            return DestructiveButtonStyle()
        case .floating:
            return FloatingButtonStyle()
        }
    }
}

// MARK: - Button Styles Implementation

struct StandardButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.98 : 1.0)
            .opacity(configuration.isPressed ? 0.8 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }
}

struct ProminentButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .background(
                RoundedRectangle(cornerRadius: CornerRadius.medium.radius)
                    .fill(SemanticColor.primaryAction)
                    .shadow(color: SemanticColor.primaryAction.opacity(0.3), radius: configuration.isPressed ? 2 : 4, y: configuration.isPressed ? 1 : 2)
            )
            .foregroundColor(SemanticColor.surfaceBackground)
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: configuration.isPressed)
    }
}

struct SubtleButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding(.horizontal, Spacing.sm.value)
            .padding(.vertical, Spacing.xs.value)
            .background(
                RoundedRectangle(cornerRadius: CornerRadius.small.radius)
                    .fill(configuration.isPressed ? SemanticColor.secondaryAction.opacity(0.2) : Color.clear)
            )
            .scaleEffect(configuration.isPressed ? 0.98 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }
}

struct DestructiveButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .foregroundColor(SemanticColor.error)
            .scaleEffect(configuration.isPressed ? 0.95 : 1.0)
            .opacity(configuration.isPressed ? 0.7 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }
}

struct FloatingButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .background(
                Circle()
                    .fill(SemanticColor.primaryAction)
                    .shadow(color: .black.opacity(0.15), radius: configuration.isPressed ? 4 : 8, y: configuration.isPressed ? 2 : 4)
            )
            .foregroundColor(SemanticColor.surfaceBackground)
            .scaleEffect(configuration.isPressed ? 0.9 : 1.0)
            .animation(.spring(response: 0.3, dampingFraction: 0.6), value: configuration.isPressed)
    }
}

// MARK: - Swipe Action Component

struct EnhancedSwipeActions<Content: View>: View {
    let content: Content
    let leadingActions: [SwipeAction]
    let trailingActions: [SwipeAction]
    
    init(
        leadingActions: [SwipeAction] = [],
        trailingActions: [SwipeAction] = [],
        @ViewBuilder content: () -> Content
    ) {
        self.leadingActions = leadingActions
        self.trailingActions = trailingActions
        self.content = content()
    }
    
    var body: some View {
        content
            .swipeActions(edge: .leading, allowsFullSwipe: false) {
                ForEach(leadingActions, id: \.id) { action in
                    Button(action.title) {
                        HapticManager.shared.trigger(action.hapticFeedback)
                        action.action()
                    }
                    .tint(action.color)
                }
            }
            .swipeActions(edge: .trailing, allowsFullSwipe: trailingActions.count == 1) {
                ForEach(trailingActions, id: \.id) { action in
                    Button(action.title, role: action.isDestructive ? .destructive : nil) {
                        HapticManager.shared.trigger(action.hapticFeedback)
                        action.action()
                    }
                    .tint(action.color)
                }
            }
    }
}

// MARK: - Swipe Action Model

struct SwipeAction {
    let id = UUID()
    let title: String
    let color: Color
    let isDestructive: Bool
    let hapticFeedback: HapticFeedbackType
    let action: () -> Void
    
    init(
        title: String,
        color: Color = .blue,
        isDestructive: Bool = false,
        hapticFeedback: HapticFeedbackType = .medium,
        action: @escaping () -> Void
    ) {
        self.title = title
        self.color = color
        self.isDestructive = isDestructive
        self.hapticFeedback = hapticFeedback
        self.action = action
    }
    
    static func edit(action: @escaping () -> Void) -> SwipeAction {
        SwipeAction(title: "編集", color: SemanticColor.primaryAction, hapticFeedback: .impact(.light), action: action)
    }
    
    static func delete(action: @escaping () -> Void) -> SwipeAction {
        SwipeAction(title: "削除", color: SemanticColor.error, isDestructive: true, hapticFeedback: .impact(.heavy), action: action)
    }
    
    static func share(action: @escaping () -> Void) -> SwipeAction {
        SwipeAction(title: "共有", color: SemanticColor.accent, hapticFeedback: .impact(.light), action: action)
    }
    
    static func favorite(action: @escaping () -> Void) -> SwipeAction {
        SwipeAction(title: "お気に入り", color: SemanticColor.warning, hapticFeedback: .impact(.light), action: action)
    }
}

// MARK: - Long Press Gesture Component

struct EnhancedLongPress: ViewModifier {
    let minimumDuration: Double
    let action: () -> Void
    let hapticFeedback: HapticFeedbackType
    
    init(
        minimumDuration: Double = 0.5,
        hapticFeedback: HapticFeedbackType = .medium,
        action: @escaping () -> Void
    ) {
        self.minimumDuration = minimumDuration
        self.action = action
        self.hapticFeedback = hapticFeedback
    }
    
    func body(content: Content) -> some View {
        content
            .onLongPressGesture(minimumDuration: minimumDuration) {
                HapticManager.shared.trigger(hapticFeedback)
                action()
            }
    }
}

// MARK: - Tap Gesture Component

struct EnhancedTapGesture: ViewModifier {
    let count: Int
    let action: () -> Void
    let hapticFeedback: HapticFeedbackType
    
    init(
        count: Int = 1,
        hapticFeedback: HapticFeedbackType = .light,
        action: @escaping () -> Void
    ) {
        self.count = count
        self.action = action
        self.hapticFeedback = hapticFeedback
    }
    
    func body(content: Content) -> some View {
        content
            .onTapGesture(count: count) {
                HapticManager.shared.trigger(hapticFeedback)
                action()
            }
    }
}

// MARK: - View Extensions

extension View {
    func enhancedSwipeActions(
        leading: [SwipeAction] = [],
        trailing: [SwipeAction] = []
    ) -> some View {
        EnhancedSwipeActions(
            leadingActions: leading,
            trailingActions: trailing
        ) {
            self
        }
    }
    
    func enhancedLongPress(
        minimumDuration: Double = 0.5,
        hapticFeedback: HapticFeedbackType = .medium,
        action: @escaping () -> Void
    ) -> some View {
        self.modifier(EnhancedLongPress(
            minimumDuration: minimumDuration,
            hapticFeedback: hapticFeedback,
            action: action
        ))
    }
    
    func enhancedTapGesture(
        count: Int = 1,
        hapticFeedback: HapticFeedbackType = .light,
        action: @escaping () -> Void
    ) -> some View {
        self.modifier(EnhancedTapGesture(
            count: count,
            hapticFeedback: hapticFeedback,
            action: action
        ))
    }
    
    func minimumTouchTarget() -> some View {
        self.frame(minWidth: 44, minHeight: 44)
            .contentShape(Rectangle())
    }
}

// MARK: - Gesture Recognizer State Management

@Observable
class GestureStateManager {
    var isPressed: Bool = false
    var dragOffset: CGSize = .zero
    var scale: CGFloat = 1.0
    
    func resetState() {
        isPressed = false
        dragOffset = .zero
        scale = 1.0
    }
}

#Preview {
    VStack(spacing: Spacing.lg.value) {
        EnhancedButton(action: { print("Standard button tapped") }) {
            Text("Standard Button")
                .font(Typography.bodyMedium.font)
                .padding()
        }
        
        EnhancedButton(action: { print("Prominent button tapped") }, style: .prominent) {
            Text("Prominent Button")
                .font(Typography.bodyMedium.font)
                .padding()
        }
        
        Text("Long press me")
            .padding()
            .background(SemanticColor.cardBackground)
            .cornerRadius(CornerRadius.medium.radius)
            .enhancedLongPress {
                print("Long pressed")
            }
        
        Text("Swipe me")
            .padding()
            .background(SemanticColor.cardBackground)
            .cornerRadius(CornerRadius.medium.radius)
            .enhancedSwipeActions(
                leading: [.edit { print("Edit") }],
                trailing: [.delete { print("Delete") }]
            )
    }
    .padding()
}