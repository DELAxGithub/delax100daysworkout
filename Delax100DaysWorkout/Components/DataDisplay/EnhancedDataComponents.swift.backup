import SwiftUI
import Charts

// MARK: - Enhanced Chart Component
/// 統一チャートコンポーネント - アクセシビリティ・レスポンシブ対応

struct EnhancedChart<Data: Identifiable, Content: ChartContent>: View {
    let data: [Data]
    let chartContent: (Data) -> Content
    let title: String
    let subtitle: String?
    let height: CGFloat
    let xAxisLabel: String?
    let yAxisLabel: String?
    let showGrid: Bool
    let animationDuration: Double
    
    init(
        data: [Data],
        title: String,
        subtitle: String? = nil,
        height: CGFloat = 200,
        xAxisLabel: String? = nil,
        yAxisLabel: String? = nil,
        showGrid: Bool = true,
        animationDuration: Double = 0.8,
        @ChartContentBuilder chartContent: @escaping (Data) -> Content
    ) {
        self.data = data
        self.title = title
        self.subtitle = subtitle
        self.height = height
        self.xAxisLabel = xAxisLabel
        self.yAxisLabel = yAxisLabel
        self.showGrid = showGrid
        self.animationDuration = animationDuration
        self.chartContent = chartContent
    }
    
    var body: some View {
        BaseCard(style: ElevatedCardStyle()) {
            VStack(alignment: .leading, spacing: Spacing.md.value) {
                // Chart Header
                VStack(alignment: .leading, spacing: Spacing.xs.value) {
                    Text(title)
                        .font(Typography.headlineMedium.font)
                        .foregroundColor(SemanticColor.primaryText)
                    
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(Typography.captionMedium.font)
                            .foregroundColor(SemanticColor.secondaryText)
                    }
                }
                
                // Chart Content
                if data.isEmpty {
                    EmptyChartView()
                } else {
                    Chart(data, id: \.id) { dataPoint in
                        chartContent(dataPoint)
                    }
                    .frame(height: height)
                    .chartXAxis {
                        AxisMarks(values: .automatic(desiredCount: 5)) { value in
                            AxisGridLine(stroke: StrokeStyle(lineWidth: showGrid ? 0.5 : 0))
                                .foregroundStyle(SemanticColor.divider)
                            AxisValueLabel()
                                .font(Typography.captionSmall.font)
                                .foregroundStyle(SemanticColor.secondaryText)
                        }
                    }
                    .chartYAxis {
                        AxisMarks { value in
                            AxisGridLine(stroke: StrokeStyle(lineWidth: showGrid ? 0.5 : 0))
                                .foregroundStyle(SemanticColor.divider)
                            AxisValueLabel()
                                .font(Typography.captionSmall.font)
                                .foregroundStyle(SemanticColor.secondaryText)
                        }
                    }
                    .chartAngleSelection(value: .constant(nil))
                    .animation(.easeInOut(duration: animationDuration), value: data.count)
                }
                
                // Axis Labels
                if let xAxisLabel = xAxisLabel || yAxisLabel != nil {
                    HStack {
                        if let xLabel = xAxisLabel {
                            Text(xLabel)
                                .font(Typography.captionSmall.font)
                                .foregroundColor(SemanticColor.secondaryText)
                        }
                        Spacer()
                        if let yLabel = yAxisLabel {
                            Text(yLabel)
                                .font(Typography.captionSmall.font)
                                .foregroundColor(SemanticColor.secondaryText)
                        }
                    }
                }
            }
        }
        .accessibilityElement(children: .combine)
        .accessibilityLabel("\(title)チャート")
        .accessibilityValue(data.isEmpty ? "データなし" : "\(data.count)個のデータポイント")
    }
}

// MARK: - Empty Chart View

struct EmptyChartView: View {
    var body: some View {
        VStack(spacing: Spacing.md.value) {
            Image(systemName: "chart.line.uptrend.xyaxis")
                .font(Typography.displaySmall.font)
                .foregroundColor(SemanticColor.secondaryText)
            
            VStack(spacing: Spacing.xs.value) {
                Text("データがありません")
                    .font(Typography.bodyMedium.font)
                    .foregroundColor(SemanticColor.primaryText)
                
                Text("記録を追加するとグラフが表示されます")
                    .font(Typography.captionMedium.font)
                    .foregroundColor(SemanticColor.secondaryText)
                    .multilineTextAlignment(.center)
            }
        }
        .frame(height: 120)
        .frame(maxWidth: .infinity)
    }
}

// MARK: - Enhanced List Row Component

struct EnhancedListRow<Content: View, Actions: View>: View {
    let content: Content
    let actions: Actions?
    let importance: RowImportance
    let dividerStyle: DividerStyle
    
    init(
        importance: RowImportance = .normal,
        dividerStyle: DividerStyle = .full,
        @ViewBuilder content: () -> Content,
        @ViewBuilder actions: () -> Actions = { EmptyView() }
    ) {
        self.content = content()
        self.actions = actions()
        self.importance = importance
        self.dividerStyle = dividerStyle
    }
    
    var body: some View {
        VStack(spacing: 0) {
            HStack(spacing: Spacing.md.value) {
                content
                
                if actions != nil {
                    actions
                }
            }
            .padding(.vertical, importance.verticalPadding)
            .padding(.horizontal, Spacing.md.value)
            .background(importance.backgroundColor)
            
            if dividerStyle != .none {
                Divider()
                    .padding(.leading, dividerStyle == .inset ? Spacing.md.value : 0)
            }
        }
    }
}

// MARK: - Row Importance Levels

enum RowImportance {
    case low
    case normal
    case high
    case critical
    
    var verticalPadding: CGFloat {
        switch self {
        case .low: return Spacing.sm.value
        case .normal: return Spacing.md.value
        case .high: return Spacing.lg.value
        case .critical: return Spacing.xl.value
        }
    }
    
    var backgroundColor: Color {
        switch self {
        case .low: return Color.clear
        case .normal: return Color.clear
        case .high: return SemanticColor.accent.opacity(0.05)
        case .critical: return SemanticColor.warning.opacity(0.1)
        }
    }
}

// MARK: - Divider Styles

enum DividerStyle {
    case none
    case full
    case inset
}

// MARK: - Enhanced ContentUnavailable Component

struct EnhancedContentUnavailable: View {
    let title: String
    let subtitle: String?
    let systemImage: String
    let actions: [ContentUnavailableAction]
    
    init(
        title: String,
        subtitle: String? = nil,
        systemImage: String,
        actions: [ContentUnavailableAction] = []
    ) {
        self.title = title
        self.subtitle = subtitle
        self.systemImage = systemImage
        self.actions = actions
    }
    
    var body: some View {
        VStack(spacing: Spacing.lg.value) {
            VStack(spacing: Spacing.md.value) {
                Image(systemName: systemImage)
                    .font(Typography.displayLarge.font)
                    .foregroundColor(SemanticColor.secondaryText)
                
                VStack(spacing: Spacing.sm.value) {
                    Text(title)
                        .font(Typography.headlineLarge.font)
                        .foregroundColor(SemanticColor.primaryText)
                        .multilineTextAlignment(.center)
                    
                    if let subtitle = subtitle {
                        Text(subtitle)
                            .font(Typography.bodyMedium.font)
                            .foregroundColor(SemanticColor.secondaryText)
                            .multilineTextAlignment(.center)
                    }
                }
            }
            
            if !actions.isEmpty {
                VStack(spacing: Spacing.sm.value) {
                    ForEach(actions, id: \.id) { action in
                        EnhancedButton(
                            action: action.action,
                            style: action.style.buttonStyle
                        ) {
                            HStack {
                                if let systemImage = action.systemImage {
                                    Image(systemName: systemImage)
                                }
                                Text(action.title)
                            }
                            .font(Typography.bodyMedium.font)
                            .padding(.horizontal, Spacing.md.value)
                            .padding(.vertical, Spacing.sm.value)
                        }
                    }
                }
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .accessibilityElement(children: .combine)
        .accessibilityLabel(title)
        .accessibilityHint(subtitle ?? "")
    }
}

// MARK: - Content Unavailable Action

struct ContentUnavailableAction {
    let id = UUID()
    let title: String
    let systemImage: String?
    let style: ActionStyle
    let action: () -> Void
    
    init(
        title: String,
        systemImage: String? = nil,
        style: ActionStyle = .primary,
        action: @escaping () -> Void
    ) {
        self.title = title
        self.systemImage = systemImage
        self.style = style
        self.action = action
    }
}

enum ActionStyle {
    case primary
    case secondary
    case subtle
    
    var buttonStyle: ButtonInteractionStyle {
        switch self {
        case .primary: return .prominent
        case .secondary: return .standard
        case .subtle: return .subtle
        }
    }
}

// MARK: - Data Summary Component

struct DataSummaryBar<T>: View {
    let items: [SummaryItem<T>]
    let orientation: SummaryOrientation
    
    init(
        items: [SummaryItem<T>],
        orientation: SummaryOrientation = .horizontal
    ) {
        self.items = items
        self.orientation = orientation
    }
    
    var body: some View {
        let layout = orientation == .horizontal ? 
            AnyLayout(HStackLayout(spacing: Spacing.md.value)) :
            AnyLayout(VStackLayout(spacing: Spacing.md.value))
        
        layout {
            ForEach(items, id: \.id) { item in
                VStack(spacing: Spacing.xs.value) {
                    Text("\(item.value)")
                        .font(Typography.headlineLarge.font)
                        .fontWeight(.bold)
                        .foregroundColor(item.color)
                    
                    Text(item.label)
                        .font(Typography.captionMedium.font)
                        .foregroundColor(SemanticColor.secondaryText)
                        .multilineTextAlignment(.center)
                }
                .frame(maxWidth: .infinity)
            }
        }
    }
}

struct SummaryItem<T> {
    let id = UUID()
    let label: String
    let value: T
    let color: Color
    
    init(label: String, value: T, color: Color = SemanticColor.primaryText) {
        self.label = label
        self.value = value
        self.color = color
    }
}

enum SummaryOrientation {
    case horizontal
    case vertical
}

fileprivate struct SampleData: Identifiable {
    let id: String
    let value: Int
}

#Preview {
    @Previewable @State var sampleData = [
        SampleData(id: "1", value: 10),
        SampleData(id: "2", value: 20),
        SampleData(id: "3", value: 15)
    ]
    
    ScrollView {
        VStack(spacing: Spacing.lg.value) {
            EnhancedContentUnavailable(
                title: "データがありません",
                subtitle: "新しいデータを追加してください",
                systemImage: "chart.bar",
                actions: [
                    ContentUnavailableAction(title: "データ追加", systemImage: "plus") { }
                ]
            )
        }
        .padding()
    }
}